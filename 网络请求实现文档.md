# iOS 网络请求实现文档

## 目录
1. [网络请求流程原理](#网络请求流程原理)
2. [URLSession vs Alamofire 对比](#urlsession-vs-alamofire-对比)
3. [项目中的网络请求实现](#项目中的网络请求实现)
4. [具体代码示例](#具体代码示例)

---

## 网络请求流程原理

### 1. 网络请求的基本流程

```
┌─────────────┐
│  应用层调用  │ (NetworkAPI.recommendPostList)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  网络管理层  │ (NetworkManager.requestGet)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  HTTP 请求   │ (URLSession / Alamofire)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  网络传输    │ (TCP/IP)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  服务器响应  │ (JSON Data)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  数据解析    │ (JSONDecoder)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  回调返回    │ (Completion Handler)
└─────────────┘
```

### 2. 网络请求的核心概念

#### 2.1 请求组成部分
- **URL**: 请求的目标地址
- **HTTP Method**: GET、POST、PUT、DELETE 等
- **Headers**: 请求头信息（如认证 token、Content-Type）
- **Parameters**: 请求参数（URL 参数或 Body 参数）
- **Timeout**: 超时时间

#### 2.2 响应处理
- **Status Code**: HTTP 状态码（200 成功，404 未找到，500 服务器错误等）
- **Response Data**: 响应数据（通常是 JSON）
- **Error Handling**: 错误处理（网络错误、解析错误等）

#### 2.3 异步处理
网络请求是异步操作，不会阻塞主线程：
- **Completion Handler**: 回调闭包，请求完成后执行
- **Result Type**: Swift 的 Result 类型，优雅地处理成功和失败

---

## URLSession vs Alamofire 对比

### 1. URLSession（系统原生）

#### 优点
- ✅ 系统原生，无需第三方依赖
- ✅ 性能优秀，内存占用小
- ✅ 完全控制，灵活性高
- ✅ 支持后台下载和上传

#### 缺点
- ❌ 代码冗长，需要手动处理很多细节
- ❌ 参数编码需要手动实现
- ❌ 错误处理较为繁琐
- ❌ 缺少高级功能（如请求重试、拦截器等）

### 2. Alamofire（第三方库）

#### 优点
- ✅ API 简洁优雅，链式调用
- ✅ 自动参数编码（URL、JSON、Multipart）
- ✅ 强大的错误处理机制
- ✅ 内置请求重试、拦截器、网络监测等高级功能
- ✅ 完善的文档和社区支持

#### 缺点
- ❌ 需要引入第三方依赖
- ❌ 增加 App 体积（约 200KB）
- ❌ 需要学习额外的 API

### 3. 功能对比表

| 功能 | URLSession | Alamofire |
|------|-----------|-----------|
| GET 请求 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| POST 请求 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 参数编码 | 手动实现 | 自动处理 |
| 请求头管理 | 手动设置 | 统一管理 |
| 错误处理 | 基础 | 强大 |
| 超时设置 | 支持 | 支持 |
| 请求取消 | 支持 | 支持 |
| 请求重试 | 需手动实现 | 内置支持 |
| 网络监测 | 需手动实现 | 内置支持 |
| 代码简洁度 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

---

## 项目中的网络请求实现

### 架构设计

```
NetworkAPI (应用层)
    ↓
NetworkManager (管理层)
    ↓
Alamofire (底层实现)
```

### 1. NetworkManager（网络管理层）

**职责**：
- 统一管理网络请求
- 配置公共请求头
- 处理通用错误
- 设置超时时间

**特点**：
- 单例模式（`shared`）
- 支持 GET 和 POST 请求
- 统一的错误处理
- 可配置的请求头

### 2. NetworkAPI（应用层）

**职责**：
- 定义具体的 API 接口
- 数据解析（JSON → Model）
- 业务逻辑封装

**特点**：
- 类型安全的 API
- 泛型数据解析
- Result 类型返回

---

## 具体代码示例

### 示例 1：GET 请求获取推荐帖子列表

#### URLSession 实现方式

```swift
// 使用 URLSession 实现（代码较长）
func recommendPostListWithURLSession(completion: @escaping (Result<PostList, Error>) -> Void) {
    // 1. 构建 URL
    let urlString = "https://github.com/xiaoyouxinqing/PostDemo/raw/master/PostDemo/Resources/PostListData_recommend_1.json"
    guard let url = URL(string: urlString) else {
        let error = NSError(domain: "Invalid URL", code: -1, userInfo: nil)
        completion(.failure(error))
        return
    }
    
    // 2. 创建 URLRequest
    var request = URLRequest(url: url)
    request.httpMethod = "GET"
    request.timeoutInterval = 15
    
    // 3. 设置请求头
    request.setValue("123", forHTTPHeaderField: "user_id")
    request.setValue("XXXXXX", forHTTPHeaderField: "token")
    
    // 4. 创建 URLSession 任务
    let task = URLSession.shared.dataTask(with: request) { data, response, error in
        // 5. 错误处理
        if let error = error {
            completion(.failure(error))
            return
        }
        
        // 6. 检查响应
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            let error = NSError(domain: "Invalid Response", code: -1, userInfo: nil)
            completion(.failure(error))
            return
        }
        
        // 7. 检查数据
        guard let data = data else {
            let error = NSError(domain: "No Data", code: -1, userInfo: nil)
            completion(.failure(error))
            return
        }
        
        // 8. 解析 JSON
        do {
            let postList = try JSONDecoder().decode(PostList.self, from: data)
            completion(.success(postList))
        } catch {
            completion(.failure(error))
        }
    }
    
    // 9. 启动任务
    task.resume()
}
```

#### Alamofire 实现方式（项目采用）

```swift
// NetworkManager.swift - 网络管理层
static func recommendPostList(completion: @escaping (Result<PostList, Error>) -> Void) {
    // 调用 NetworkManager 的 GET 请求方法
    NetworkManager.shared.requestGet(path: "PostListData_recommend_1.json", parameters: nil) { result in
        switch result {
        case let .success(data):
            // 解析数据
            let parseResult: Result<PostList, Error> = self.parseData(data)
            completion(parseResult)
        case let .failure(error):
            completion(.failure(error))
        }
    }
}

// NetworkManager.swift - 底层实现
@discardableResult
func requestGet(path: String, parameters: Parameters?, completion: @escaping NetworkRequestCompletion) -> DataRequest {
    AF.request(NetworkAPIBaseURL + path,
               parameters: parameters,
               headers: commonHeaders,
               requestModifier: { $0.timeoutInterval = 15 })
        .responseData { response in
            switch response.result {
            case let .success(data): completion(.success(data))
            case let .failure(error): completion(self.handleError(error))
            }
    }
}
```

**对比分析**：
- URLSession：需要 40+ 行代码，手动处理各种细节
- Alamofire：只需 10+ 行代码，简洁优雅

### 示例 2：POST 请求创建帖子

#### URLSession 实现方式

```swift
func createPostWithURLSession(text: String, completion: @escaping (Result<Post, Error>) -> Void) {
    // 1. 构建 URL
    let urlString = "https://github.com/xiaoyouxinqing/PostDemo/raw/master/PostDemo/Resources/createpost"
    guard let url = URL(string: urlString) else {
        let error = NSError(domain: "Invalid URL", code: -1, userInfo: nil)
        completion(.failure(error))
        return
    }
    
    // 2. 创建 URLRequest
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.timeoutInterval = 15
    
    // 3. 设置请求头
    request.setValue("123", forHTTPHeaderField: "user_id")
    request.setValue("XXXXXX", forHTTPHeaderField: "token")
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
    
    // 4. 编码参数为 JSON
    let parameters = ["text": text]
    do {
        let jsonData = try JSONSerialization.data(withJSONObject: parameters, options: .prettyPrinted)
        request.httpBody = jsonData
    } catch {
        completion(.failure(error))
        return
    }
    
    // 5. 创建任务并处理响应（与 GET 类似）
    let task = URLSession.shared.dataTask(with: request) { data, response, error in
        // ... 错误处理和数据解析（同上）
    }
    
    task.resume()
}
```

#### Alamofire 实现方式（项目采用）

```swift
// NetworkAPI.swift
static func createPost(text: String, completion: @escaping (Result<Post, Error>) -> Void) {
    NetworkManager.shared.requestPost(path: "createpost", parameters: ["text": text]) { result in
        switch result {
        case let .success(data):
            let parseResult: Result<Post, Error> = self.parseData(data)
            completion(parseResult)
        case let .failure(error):
            completion(.failure(error))
        }
    }
}

// NetworkManager.swift
@discardableResult
func requestPost(path: String, parameters: Parameters?, completion: @escaping NetworkRequestCompletion) -> DataRequest {
    AF.request(NetworkAPIBaseURL + path,
               method: .post,
               parameters: parameters,
               encoding: JSONEncoding.prettyPrinted,
               headers: commonHeaders,
               requestModifier: { $0.timeoutInterval = 15 })
        .responseData { response in
            switch response.result {
            case let .success(data): completion(.success(data))
            case let .failure(error): completion(self.handleError(error))
            }
    }
}
```

### 示例 3：错误处理

#### 项目中的错误处理机制

```swift
// NetworkManager.swift
private func handleError(_ error: AFError) -> NetworkRequestResult {
    if let underlyingError = error.underlyingError {
        let nserror = underlyingError as NSError
        let code = nserror.code
        
        // 检查常见网络错误
        if  code == NSURLErrorNotConnectedToInternet ||
            code == NSURLErrorTimedOut ||
            code == NSURLErrorInternationalRoamingOff ||
            code == NSURLErrorDataNotAllowed ||
            code == NSURLErrorCannotFindHost ||
            code == NSURLErrorCannotConnectToHost ||
            code == NSURLErrorNetworkConnectionLost {
            
            // 自定义错误信息
            var userInfo = nserror.userInfo
            userInfo[NSLocalizedDescriptionKey] = "网络连接有问题喔～"
            let currentError = NSError(domain: nserror.domain, code: code, userInfo: userInfo)
            return .failure(currentError)
        }
    }
    return .failure(error)
}
```

**错误类型**：
- `NSURLErrorNotConnectedToInternet`: 无网络连接
- `NSURLErrorTimedOut`: 请求超时
- `NSURLErrorCannotFindHost`: 找不到服务器
- `NSURLErrorCannotConnectToHost`: 无法连接到服务器
- `NSURLErrorNetworkConnectionLost`: 网络连接丢失

### 示例 4：数据解析

```swift
// NetworkAPI.swift
private static func parseData<T: Decodable>(_ data: Data) -> Result<T, Error> {
    guard let decodedData = try? JSONDecoder().decode(T.self, from: data) else {
        let error = NSError(domain: "NetworkAPIError", code: 0, 
                          userInfo: [NSLocalizedDescriptionKey: "Can not parse data"])
        return .failure(error)
    }
    return .success(decodedData)
}
```

**泛型解析的优势**：
- 类型安全：编译时检查类型
- 代码复用：一个方法处理所有类型
- 自动映射：JSON 自动映射到 Swift 模型

---

## 使用示例

### 在 SwiftUI 中调用网络请求

```swift
struct PostListView: View {
    @State private var posts: [Post] = []
    @State private var isLoading = false
    @State private var errorMessage: String?
    
    var body: some View {
        List(posts) { post in
            PostCellView(post: post)
        }
        .onAppear {
            loadPosts()
        }
    }
    
    private func loadPosts() {
        isLoading = true
        
        // 调用网络请求
        NetworkAPI.recommendPostList { result in
            DispatchQueue.main.async {
                isLoading = false
                
                switch result {
                case .success(let postList):
                    self.posts = postList.list
                case .failure(let error):
                    self.errorMessage = error.localizedDescription
                }
            }
        }
    }
}
```

---

## 总结

### 项目采用 Alamofire 的原因

1. **代码简洁**：减少 70% 的样板代码
2. **易于维护**：统一的 API 风格
3. **功能强大**：内置错误处理、参数编码等
4. **社区支持**：成熟稳定，文档完善

### 最佳实践

1. **分层架构**：NetworkAPI（应用层）+ NetworkManager（管理层）
2. **统一管理**：公共配置（BaseURL、Headers）集中管理
3. **错误处理**：友好的错误提示
4. **类型安全**：使用泛型和 Result 类型
5. **异步处理**：不阻塞主线程

### 扩展建议

1. **添加缓存**：使用 URLCache 或第三方缓存库
2. **请求重试**：网络失败时自动重试
3. **请求取消**：页面销毁时取消未完成的请求
4. **网络监测**：检测网络状态变化
5. **日志记录**：记录请求和响应，便于调试

