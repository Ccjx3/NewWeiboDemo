---
alwaysApply: true
---

# Swift & SwiftUI 项目规则

## 项目概述
这是一个使用 SwiftData 的社交媒体帖子列表应用，展示了如何使用 SwiftData 进行数据持久化，以及如何与 JSON 文件进行数据同步。

## 代码风格规范

### 1. 命名规范
- **类型名称**：使用 PascalCase（如 `PostListView`, `ImageLoader`）
- **变量和函数**：使用 camelCase（如 `modelContext`, `loadPostsFromJSON`）
- **常量**：使用 camelCase，私有常量可以使用 `k` 前缀（如 `kImageSpace`）
- **文件名**：与主要类型名称保持一致
- **注释内容**：要求实现一个模块就对整个模块进行注释，例如：//实现了xxx功能；实现一些复杂功能的时候，应该对函数写法以及功能进行，所用到的协议，组件进行说明，例如：使用'async'关键字实现异步功能

### 2. 注释规范
- 每个文件顶部包含标准头部注释（项目名、创建者、日期）
- 使用 `///` 进行文档注释，描述类型、方法和属性的用途
- 复杂逻辑添加行内注释说明
- 使用 emoji 标记日志输出（✅ 成功、❌ 错误、⚠️ 警告、📂 文件、📊 数据）

### 3. 代码组织
- 使用 `// MARK: -` 分隔代码区域
- 属性声明顺序：`@Environment` → `@Query` → `@State` → 普通属性
- 方法顺序：初始化方法 → 视图 body → 私有辅助方法
- 每个视图组件单独一个文件

## SwiftData 最佳实践

### 1. 模型定义
```swift
@Model
final class Post {
    var id: Int
    var name: String
    var images: [String]  // 存储文件名，不存储实际图片数据
    
    init(id: Int, name: String, images: [String]) {
        self.id = id
        self.name = name
        self.images = images
    }
}
```

### 2. 数据查询
- 使用 `@Query` 进行自动查询和更新
- 使用 `FetchDescriptor` 进行手动查询
- 使用 `#Predicate` 宏进行类型安全的过滤

```swift
@Query(sort: \Post.id, order: .forward) private var posts: [Post]

// 手动查询
let descriptor = FetchDescriptor<Post>(
    predicate: #Predicate<Post> { p in p.id == postId }
)
let results = try modelContext.fetch(descriptor)
```

### 3. 数据修改
- 使用 `@Bindable` 包装模型对象以支持双向绑定
- 修改后调用 `modelContext.save()` 保存更改
- 使用 `modelContext.insert()` 插入新对象
- 使用 `modelContext.delete()` 删除对象

### 4. 数据同步
- 数据变更后同步到 JSON 文件
- 使用 `JSONService` 统一管理 JSON 操作
- 首次启动时从 JSON 加载初始数据

## SwiftUI 视图规范

### 1. 视图结构
```swift
struct MyView: View {
    // 1. Environment 和 Query
    @Environment(\.modelContext) private var modelContext
    @Query private var items: [Item]
    
    // 2. State 变量
    @State private var isLoading = false
    
    // 3. Body
    var body: some View {
        // 视图内容
    }
    
    // 4. 私有辅助方法
    private func helperMethod() {
        // 实现
    }
}
```

### 2. 图片加载
- 图片文件存储在 `Resources` 文件夹
- 使用 `ImageLoader.loadUIImage(name:)` 加载图片
- 必须先调用 `.resizable()` 再使用 `.scaledToFill()` 或 `.scaledToFit()`
- 提供占位图处理加载失败的情况

```swift
if let uiImage = ImageLoader.loadUIImage(name: imageName) {
    Image(uiImage: uiImage)
        .resizable()
        .scaledToFill()
        .frame(width: 100, height: 100)
        .clipped()
} else {
    // 占位图
    Rectangle()
        .fill(Color.gray.opacity(0.3))
        .overlay(Image(systemName: "photo"))
}
```

### 3. 列表优化
- 使用 `.listRowInsets()` 自定义单元格边距
- 使用 `.listRowSeparator(.hidden)` 隐藏分隔线
- 使用 `.listStyle(.plain)` 设置列表样式
- 空状态提供友好的提示信息

### 4. 异步操作
- 使用 `.task` 修饰符执行异步初始化
- 使用 `@MainActor` 确保 UI 更新在主线程
- 使用标志位避免重复加载（如 `hasLoadedInitialData`）

## 错误处理

### 1. 日志输出
```swift
print("✅ 成功加载 \(count) 条数据")
print("❌ 加载失败: \(error.localizedDescription)")
print("⚠️ 警告：数据已存在")
print("📂 文件路径: \(path)")
```

### 2. 可选值处理
- 优先使用 `guard let` 进行提前返回
- 使用 `if let` 处理可选值
- 提供合理的默认值或占位内容

### 3. 异常捕获
```swift
do {
    try modelContext.save()
} catch {
    print("❌ 保存失败: \(error.localizedDescription)")
}
```

## 性能优化

### 1. 图片处理
- 不在数据库中存储图片数据，只存储文件名
- 使用 `UIImage` 而不是 `Data` 进行图片加载
- 图片视图使用 `.clipped()` 避免超出边界

### 2. 数据加载
- 避免重复加载数据（使用标志位）
- 批量插入数据而不是逐条插入
- 检查重复数据避免冗余

### 3. 视图更新
- 使用 `@Bindable` 实现精确更新
- 使用 `.onChange` 监听特定属性变化
- 避免不必要的视图重建

## 项目特定规则

### 1. 文件组织
```
newTestSwiftData/
├── Models/          # 数据模型
├── Views/           # 视图组件
├── Services/        # 服务类（如 JSONService）
└── Resources/       # 资源文件（图片、JSON）
```

### 2. JSON 数据格式
```json
{
  "list": [
    {
      "id": 1000,
      "avatar": "avatar.jpg",
      "vip": true,
      "name": "用户名",
      "date": "2020-01-05 22:51",
      "isFollowed": false,
      "text": "帖子内容",
      "images": ["image1.jpg", "image2.jpg"],
      "commentCount": 100,
      "likeCount": 200,
      "isLiked": false
    }
  ]
}
```

### 3. 数据同步时机
- 添加新帖子后同步
- 删除帖子后同步
- 点赞状态改变后同步
- 关注状态改变后同步

## 常见问题解决方案

### 1. 图片无法显示
- 确保图片文件在 `Resources` 文件夹中
- 确保图片已添加到 Xcode 项目的 Bundle
- 使用 `ImageLoader.loadUIImage(name:)` 加载
- 确保调用 `.resizable()` 后再使用 `.scaledToFill()`

### 2. 数据重复加载
- 使用 `hasLoadedInitialData` 标志位
- 在加载前检查数据库是否已有数据
- 使用 `.task` 而不是 `.onAppear`

### 3. EXC_BAD_ACCESS 错误
- 避免在 `@Query` 结果为空时访问元素
- 使用可选绑定处理可能为 nil 的值
- 确保 `modelContext` 可用后再操作

### 4. JSON 文件找不到
- 检查文件是否在 Xcode 项目中
- 检查 Target Membership 是否正确
- 使用多种路径尝试加载（Bundle.main.url）

## 测试和调试

### 1. Preview 配置
```swift
#Preview {
    let config = ModelConfiguration(isStoredInMemoryOnly: true)
    let container = try! ModelContainer(for: Post.self, configurations: config)
    
    return PostListView()
        .modelContainer(container)
}
```

### 2. 调试输出
- 使用 emoji 标记不同类型的日志
- 输出关键步骤的执行状态
- 记录错误的详细信息

### 3. 内存数据库
- Preview 使用内存数据库避免污染真实数据
- 测试时使用 `isStoredInMemoryOnly: true`

## 代码审查清单

- [ ] 所有公开类型和方法都有文档注释
- [ ] 使用了正确的命名规范
- [ ] 图片加载使用了 `ImageLoader`
- [ ] 数据修改后进行了同步
- [ ] 异步操作使用了 `@MainActor`
- [ ] 提供了错误处理和日志输出
- [ ] 空状态有友好的提示
- [ ] Preview 配置正确
- [ ] 没有硬编码的魔法数字
- [ ] 代码结构清晰，职责单一
