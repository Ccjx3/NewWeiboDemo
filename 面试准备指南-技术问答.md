# iOS 开发校招面试准备指南 - 技术问答

## 📚 目录

1. [SwiftUI 相关问题](#swiftui-相关问题)
2. [SwiftData 相关问题](#swiftdata-相关问题)
3. [网络请求相关问题](#网络请求相关问题)
4. [性能优化相关问题](#性能优化相关问题)
5. [架构设计相关问题](#架构设计相关问题)
6. [项目难点相关问题](#项目难点相关问题)

---

## SwiftUI 相关问题

### Q1: SwiftUI 和 UIKit 有什么区别？你为什么选择 SwiftUI？

**标准答案**:

**区别**:
1. **编程范式**: SwiftUI 是声明式，UIKit 是命令式
2. **代码量**: SwiftUI 代码量减少 40-60%
3. **实时预览**: SwiftUI 支持 Canvas 实时预览
4. **状态管理**: SwiftUI 有 `@State`、`@Binding` 等属性包装器
5. **跨平台**: SwiftUI 可以轻松适配 iOS、macOS、watchOS

**选择 SwiftUI 的原因**:
- 项目是新项目，没有历史包袱
- SwiftUI 是 Apple 推荐的未来方向
- 开发效率更高，适合快速迭代
- 与 SwiftData 深度集成

**代码对比**:
```swift
// UIKit 方式（命令式）
let label = UILabel()
label.text = "Hello"
label.textColor = .black
view.addSubview(label)

// SwiftUI 方式（声明式）
Text("Hello")
    .foregroundColor(.black)
```

---

### Q2: 解释 @State、@Binding、@ObservedObject、@StateObject 的区别

**标准答案**:

| 属性包装器 | 所有权 | 生命周期 | 使用场景 |
|-----------|--------|----------|----------|
| `@State` | 视图拥有 | 视图生命周期 | 视图内部的简单状态 |
| `@Binding` | 不拥有 | 父视图控制 | 子视图修改父视图状态 |
| `@ObservedObject` | 不拥有 | 外部控制 | 引用外部 ViewModel |
| `@StateObject` | 视图拥有 | 视图生命周期 | 视图创建并拥有 ViewModel |

**项目中的实际应用**:
```swift
// @State - 视图内部状态
struct PostCellView: View {
    @State private var showDeletePopover = false  // 视图拥有
}

// @Binding - 父子视图通信
struct HomeNavigationBar: View {
    @Binding var leftPercent: CGFloat  // 不拥有，由父视图控制
}

// @StateObject - 创建并拥有 ViewModel
struct PostVideoPlayer: View {
    @StateObject private var manager = VideoPlayerManager()  // 视图拥有
}

// @ObservedObject - 引用外部对象
class VideoPlayerManager: ObservableObject {
    @Published var isPlaying = false  // 发布变化
}
```

---

### Q3: SwiftUI 的视图更新机制是什么？

**标准答案**:

**更新流程**:
```
状态变化 → 标记视图为脏 → 重新计算 body → Diff 算法 → 更新 UI
```

**关键点**:
1. **值类型**: SwiftUI 的 View 是 struct（值类型），不是 class
2. **不可变性**: 每次状态变化都创建新的视图值
3. **Diff 算法**: SwiftUI 只更新变化的部分，不是整个视图
4. **批量更新**: 多个状态变化会合并成一次更新

**项目中的例子**:
```swift
struct PostCellView: View {
    @Bindable var post: Post
    
    var body: some View {
        // 当 post.isLiked 变化时
        Button(action: {
            post.isLiked.toggle()  // 1. 状态变化
        }) {
            Image(systemName: post.isLiked ? "heart.fill" : "heart")
            // 2. SwiftUI 重新计算 body
            // 3. Diff 发现图标变化
            // 4. 只更新图标，不重建整个视图
        }
    }
}
```

---

### Q4: LazyVStack 和 VStack 有什么区别？

**标准答案**:

| 特性 | VStack | LazyVStack |
|------|--------|------------|
| 加载时机 | 立即创建所有子视图 | 按需创建（滚动到时） |
| 内存占用 | 高（所有视图都在内存） | 低（只保留可见视图） |
| 性能 | 数据少时更快 | 数据多时更快 |
| 使用场景 | < 20 个子视图 | 长列表、无限滚动 |

**项目中的应用**:
```swift
ScrollView {
    LazyVStack(spacing: 12) {  // 使用 LazyVStack
        ForEach(posts) { post in
            PostCellView(post: post)
            // 只有滚动到这个位置时才创建视图
            // 滚出屏幕后可能被释放
        }
    }
}
```

**性能对比**:
- 100 个帖子，VStack 会立即创建 100 个视图（卡顿）
- 100 个帖子，LazyVStack 只创建可见的 5-10 个视图（流畅）

---

## SwiftData 相关问题

### Q5: SwiftData 和 Core Data 有什么区别？

**标准答案**:

| 特性 | Core Data | SwiftData |
|------|-----------|-----------|
| 定义模型 | NSManagedObject 子类 | @Model 宏 |
| 代码量 | 多（需要 .xcdatamodeld） | 少（纯 Swift） |
| 类型安全 | 弱（运行时检查） | 强（编译时检查） |
| 查询方式 | NSFetchRequest | @Query / Predicate |
| SwiftUI 集成 | 需要手动绑定 | 自动同步 |
| 学习曲线 | 陡峭 | 平缓 |

**代码对比**:
```swift
// Core Data（复杂）
@NSManaged var id: Int64
@NSManaged var name: String?

let fetchRequest: NSFetchRequest<Post> = Post.fetchRequest()
fetchRequest.predicate = NSPredicate(format: "id == %d", 1000)
let posts = try? context.fetch(fetchRequest)

// SwiftData（简洁）
@Model
final class Post {
    var id: Int
    var name: String
}

@Query(filter: #Predicate<Post> { $0.id == 1000 })
private var posts: [Post]
```

---

### Q6: 为什么图片存储文件名而不是二进制数据？

**标准答案**:

**存储文件名的优势**:
1. **数据库体积小**: 文件名 < 100 字节，图片可能几 MB
2. **查询速度快**: 字符串比较比二进制快得多
3. **内存占用低**: 不需要一次性加载所有图片到内存
4. **支持异步加载**: 可以渐进式加载，不阻塞 UI
5. **便于管理**: 图片统一放在 Resources，便于替换和更新

**对比表**:

| 方案 | 数据库大小 | 查询速度 | 内存占用 | 适用场景 |
|------|-----------|---------|---------|----------|
| 文件名 | 小（KB级） | 快 | 低 | ✅ 推荐 |
| 二进制 | 大（MB级） | 慢 | 高 | 小图标 |
| URL | 小（KB级） | 快 | 低 | 网络图片 |

**项目中的实现**:
```swift
@Model
final class Post {
    var avatar: String  // "avatar.jpg"（约 20 字节）
    var images: [String]  // ["img1.jpg", "img2.jpg"]（约 50 字节）
    
    // 而不是
    // var avatarData: Data?  // 可能 2MB
}

// 加载图片
WebImage(url: URL(string: NetworkAPIBaseURL + post.avatar))
```

---

### Q7: @Query 是如何实现自动更新的？

**标准答案**:

**原理**:
1. `@Query` 是一个属性包装器（Property Wrapper）
2. 它内部持有一个 `FetchDescriptor`
3. 监听 `ModelContext` 的变化通知
4. 当数据变化时，自动重新查询
5. 触发视图的 `body` 重新计算

**流程图**:
```
数据变化 → ModelContext 发送通知 → @Query 接收通知 
→ 重新执行查询 → 更新 posts 数组 → 触发视图更新
```

**项目中的例子**:
```swift
struct PostListView: View {
    @Query(sort: \Post.id) private var posts: [Post]
    // ↑ 自动监听 Post 的变化
    
    var body: some View {
        List {
            ForEach(posts) { post in
                PostCellView(post: post)
            }
        }
    }
}

// 在其他地方添加帖子
modelContext.insert(newPost)
try? modelContext.save()
// ↑ 保存后，@Query 自动更新，视图自动刷新
```

---

## 网络请求相关问题

### Q8: 为什么使用 Alamofire 而不是 URLSession？

**标准答案**:

**Alamofire 的优势**:
1. **代码简洁**: 减少 70% 的样板代码
2. **参数编码**: 自动处理 URL 编码、JSON 编码
3. **错误处理**: 统一的错误处理机制
4. **高级功能**: 请求重试、拦截器、网络监测
5. **链式调用**: API 更优雅

**代码对比**:
```swift
// URLSession（40+ 行）
var request = URLRequest(url: url)
request.httpMethod = "POST"
request.setValue("application/json", forHTTPHeaderField: "Content-Type")
let jsonData = try JSONSerialization.data(withJSONObject: parameters)
request.httpBody = jsonData
URLSession.shared.dataTask(with: request) { data, response, error in
    // 处理响应...
}.resume()

// Alamofire（10 行）
AF.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default)
    .responseData { response in
        // 处理响应...
    }
```

**项目中的架构**:
```
NetworkAPI (应用层) - 定义具体接口
    ↓
NetworkManager (管理层) - 统一配置
    ↓
Alamofire (底层) - 执行请求
```

---

### Q9: 如何处理网络请求的错误？

**标准答案**:

**错误分类**:
1. **网络错误**: 无网络、超时、连接失败
2. **HTTP 错误**: 404、500、401
3. **解析错误**: JSON 格式错误
4. **业务错误**: 服务器返回的业务错误码

**项目中的实现**:
```swift
private func handleError(_ error: AFError) -> NetworkRequestResult {
    if let underlyingError = error.underlyingError {
        let nserror = underlyingError as NSError
        let code = nserror.code
        
        // 网络错误
        if code == NSURLErrorNotConnectedToInternet {
            return .failure(NSError(
                domain: "网络连接有问题喔～",
                code: code
            ))
        }
        
        // 超时错误
        if code == NSURLErrorTimedOut {
            return .failure(NSError(
                domain: "请求超时，请稍后重试",
                code: code
            ))
        }
    }
    
    return .failure(error)
}
```

**最佳实践**:
- 将技术错误转换为用户友好的提示
- 记录详细的错误日志便于调试
- 提供重试机制
- 区分可恢复和不可恢复的错误

---

## 性能优化相关问题

### Q10: 你在项目中做了哪些性能优化？

**标准答案**:

**1. 列表性能优化**
```swift
// ✅ 使用 LazyVStack 懒加载
ScrollView {
    LazyVStack {
        ForEach(posts) { post in
            PostCellView(post: post)
        }
    }
}

// ❌ 不要使用 VStack（会一次性创建所有视图）
```

**2. 图片加载优化**
```swift
// ✅ 使用 SDWebImage 异步加载和缓存
WebImage(url: imageURL)
    .placeholder { ProgressView() }  // 占位符
    .transition(.fade)  // 淡入动画

// ❌ 不要同步加载图片（会阻塞主线程）
```

**3. 视频播放优化**
```swift
// ✅ 页面消失时释放播放器
.onDisappear {
    player?.pause()
    player = nil  // 释放资源
}

// ✅ 按需创建播放器
if post.hasVideo {
    PostVideoPlayer(videoUrl: post.videoUrl)
}
```

**4. 数据库查询优化**
```swift
// ✅ 使用 Predicate 过滤，减少内存占用
@Query(
    filter: #Predicate<Post> { post in
        post.id >= 1000 && post.id < 2000
    }
) private var posts: [Post]

// ❌ 不要查询所有数据再过滤
```

**5. 状态管理优化**
```swift
// ✅ 使用 @Bindable 直接修改模型
@Bindable var post: Post
post.isLiked.toggle()  // 只更新这一个属性

// ❌ 不要复制整个对象
```

---

### Q11: 如何检测和解决内存泄漏？

**标准答案**:

**检测方法**:
1. **Instruments**: 使用 Leaks 工具检测
2. **Memory Graph**: Xcode 的内存图调试
3. **Allocations**: 查看内存分配情况

**常见原因**:
1. **循环引用**: 闭包捕获 self
2. **未释放的观察者**: NotificationCenter、KVO
3. **定时器**: Timer 强引用 target

**项目中的解决方案**:
```swift
// ✅ 使用 weak self 避免循环引用
playerItem.publisher(for: \.status)
    .sink { [weak self] status in  // weak self
        guard let self = self else { return }
        self.handleStatus(status)
    }
    .store(in: &cancellables)

// ✅ 在 deinit 中清理资源
deinit {
    cancellables.removeAll()
    player?.pause()
    player = nil
}
```

---

## 架构设计相关问题

### Q12: 你的项目使用了什么架构模式？

**标准答案**:

**MVVM 架构**（隐式 ViewModel）

```
Model (Post) - 数据模型
    ↓
View (SwiftUI) - 视图层
    ↓
ViewModel (隐式) - @State、@Query 充当 ViewModel
```

**分层设计**:
```
Presentation Layer (视图层)
├── Views/
│   ├── HomeView.swift
│   ├── PostCellView.swift
│   └── PostDetailView.swift

Business Layer (业务层)
├── Services/
│   └── JSONService.swift

Data Layer (数据层)
├── Models/
│   └── Post.swift
├── Network/
│   ├── NetworkManager.swift
│   └── NetworkAPI.swift
```

**设计模式**:
1. **单例模式**: NetworkManager.shared
2. **工厂模式**: Post(from: json)
3. **观察者模式**: @Published、Combine
4. **依赖注入**: Environment 注入 ModelContext

---

### Q13: 如何实现模块解耦？

**标准答案**:

**1. 协议抽象**
```swift
// 定义协议
protocol PostServiceProtocol {
    func loadPosts() -> [Post]
    func savePost(_ post: Post)
}

// 实现协议
class JSONService: PostServiceProtocol {
    func loadPosts() -> [Post] { ... }
    func savePost(_ post: Post) { ... }
}

// 依赖协议而非具体实现
class PostViewModel {
    let service: PostServiceProtocol  // 依赖抽象
    
    init(service: PostServiceProtocol) {
        self.service = service
    }
}
```

**2. 依赖注入**
```swift
// 通过 Environment 注入
@Environment(\.modelContext) private var modelContext

// 通过初始化注入
struct PostListView: View {
    let service: PostServiceProtocol
    
    init(service: PostServiceProtocol = JSONService()) {
        self.service = service
    }
}
```

**3. 分层隔离**
- 视图层不直接访问网络层
- 通过服务层（Service）作为中间层
- 每层只依赖下一层，不跨层调用

---

## 项目难点相关问题

### Q14: 项目中遇到的最大技术难点是什么？如何解决的？

**标准答案**（选择一个你最熟悉的）:

**难点 1: 视频播放器静音按钮不生效**

**问题描述**:
- 自定义的静音按钮点击后，图标变化了，但视频声音没有变化
- AVPlayer 的原生控制栏可以正常控制静音

**排查过程**:
1. 打印日志，发现 `player.isMuted` 确实被修改了
2. 使用 Combine 监听 `isMuted` 属性变化，发现被系统重置
3. 查阅文档，发现 VideoPlayer 的原生控制栏会覆盖自定义设置

**解决方案**:
```swift
// 1. 使用 @StateObject 管理状态
@StateObject private var manager = VideoPlayerManager()

// 2. 双向绑定
player.publisher(for: \.isMuted)
    .sink { [weak manager] isMuted in
        manager?.isMuted = isMuted  // 同步状态
    }

// 3. 自定义按钮放在最上层
.overlay(alignment: .topTrailing) {
    Button { 
        manager.isMuted.toggle()
        player.isMuted = manager.isMuted
    }
    .zIndex(1)  // 确保在最上层
}
```

**收获**:
- 学会了使用 Combine 监听属性变化
- 理解了 SwiftUI 的视图层级和事件传递
- 掌握了 AVPlayer 的状态管理

---

**难点 2: 图片浏览器索引定位不准确**

**问题描述**:
- 点击第 3 张图片，浏览器总是显示第 1 张
- 使用 `selectedImageIndex` 传递索引，但不生效

**排查过程**:
1. 打印日志，发现 `selectedImageIndex` 值是正确的
2. 发现 SwiftUI 复用了之前的视图实例
3. 浏览器初始化时使用的是旧的索引值

**解决方案**:
```swift
.fullScreenCover(isPresented: $showPhotoBrowser) {
    NativePhotoBrowser(
        images: images,
        initialIndex: selectedImageIndex
    )
    .id(selectedImageIndex)  // 关键：使用 id 强制重新创建
}

// 点击图片时延迟显示，确保状态更新
private func handleImageTap(index: Int) {
    selectedImageIndex = index
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.01) {
        showPhotoBrowser = true
    }
}
```

**收获**:
- 理解了 SwiftUI 的视图复用机制
- 学会了使用 `.id()` 强制重新创建视图
- 掌握了异步状态更新的技巧

---

### Q15: 如果让你重新设计这个项目，你会做哪些改进？

**标准答案**:

**1. 架构改进**
- 引入明确的 ViewModel 层，而不是隐式的
- 使用 Repository 模式统一数据访问
- 实现依赖注入容器

**2. 功能改进**
- 添加用户认证和授权
- 实现真实的网络 API 对接
- 添加推送通知功能
- 实现草稿箱功能

**3. 性能改进**
- 实现图片压缩和上传
- 添加数据预加载和预缓存
- 实现虚拟列表（只渲染可见区域）
- 优化数据库查询（添加索引）

**4. 测试改进**
- 添加单元测试（覆盖率 > 80%）
- 添加 UI 测试
- 实现持续集成（CI/CD）

**5. 用户体验改进**
- 添加骨架屏加载效果
- 实现更丰富的动画
- 支持暗黑模式
- 添加无障碍支持（Accessibility）

---

## 🎯 面试技巧

### 回答问题的 STAR 法则

**S**ituation（情境）: 描述项目背景  
**T**ask（任务）: 说明你的任务  
**A**ction（行动）: 详细说明你的解决方案  
**R**esult（结果）: 总结成果和收获

**示例**:
"在这个项目中（S），我需要实现一个类似微博的视频播放功能（T）。我使用 AVKit 的 VideoPlayer 实现基础播放，通过 Combine 监听播放状态，添加了自定义的静音按钮和全屏功能（A）。最终实现了流畅的视频播放体验，支持自动循环、静音切换和全屏播放（R）。"

### 展示技术深度的技巧

1. **从原理说起**: 不只说"我用了 XX"，要说"我用了 XX，它的原理是..."
2. **对比方案**: "我对比了 A 和 B 方案，最终选择 A 是因为..."
3. **量化结果**: "优化后，列表滚动帧率从 30fps 提升到 60fps"
4. **举一反三**: "这个问题让我想到了 XX 场景，也可以用类似方法解决"

### 避免的雷区

1. ❌ "我不知道"（应该说"这个我还没深入研究，但我的理解是..."）
2. ❌ "这个很简单"（应该说"这个功能涉及到..."）
3. ❌ "我照着教程做的"（应该说"我参考了 XX，并做了 XX 改进"）
4. ❌ 说谎或夸大（面试官一问就露馅）

---

## 📚 推荐学习资源

### 官方文档
- [SwiftUI 官方文档](https://developer.apple.com/documentation/swiftui)
- [SwiftData 官方文档](https://developer.apple.com/documentation/swiftdata)
- [Combine 官方文档](https://developer.apple.com/documentation/combine)

### 进阶学习
- WWDC 视频（搜索 SwiftUI、SwiftData）
- objc.io 的 SwiftUI 系列文章
- Hacking with Swift 的教程

### 面试准备
- LeetCode 算法题（每天 1-2 题）
- iOS 面试题集锦
- 系统设计题（如何设计微信朋友圈）

---

祝你面试顺利！🎉

